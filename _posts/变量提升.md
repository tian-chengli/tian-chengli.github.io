---
title: 变量提升
date: 2018-05-04 17:57:05
tags:
---
### 变量提升
> 在`当前作用域`中，JS代码自上而下执行`之前`，浏览器首先会把所有带`var/function`关键字的，进行提前的`声明(declare)/定义(defined)`，这种提前声明变量的机制，我们称之为`变量提升`。
 > - 变量提升阶段：带var的只声明未定义。带function的声明和赋值都完成了。
 - 变量提升只发生在当前作用域，
 - 在全局作用域下声明的函数或者变量是全局变量，同理在私有作用域声明的变量是私有变量，带var、function的才是声明
 - 浏览器很懒做过的事情不会重复执行第二遍，当代码执行遇到创建函数这部分代码后直接的跳过即可，因为在变量提升阶段就已经完成函数的执行了
 - （函数执行）1.形成一个私有作用域。2.形参赋值。3.变量提升。
 在es3和es5语法规法中只有全局作用域和函数执行的私有作用域（栈内存）其他的大括号不会形成栈内存。
 ####  变量提升规律
 > 1.只会对等号左边的进行变量提升（function作为值时不会变量提升）
 2.return后面的也不能变量提升，对return下面的还是要变量提升
 3.重名变量，不会重复声明，但可以多次被定义赋值，后面的定义会把前面的值覆盖。
 4.自执行函数本身的function不进行变量提升，定义+执行一起完成
 5.不管条件是否成立，对待var关键字的进行变量提升，但是function关键字，标准浏览器下声明，ie9以上浏览器是声明+定义
  `带var不带var的区别？`
  > 在全局作用域下声明一个变量，也相当于给window全局对象设置了一个属性，变量的值就是属性值（私有作用域中声明的私有变量和window没啥关系 ）
  > - 带var进行变量提升
 - 不带var ：在全局作用域中，仅仅给全局对象设置了一个新的属性名把window省略了.
 - 项目当中，目的是创建变量，最好不要省略var，更严谨。
 - 全局变量和window中的属性存在映射机制。

 > `私有作用域中带var和不带var也有区别：`
 带var的在私有作用域变量提升阶段都声明为私有变量和外界没有任何关系
 不带var不是私有变量会向他的上级作用域查找，看是否为上级的变量，不是的话就向上级作用域找，一直找到window为止，我们把这种查找机制叫做作用域链.也就是我们在私有作用域中操作的这个私有变量是一直操作别人的

 - `不带var的查找顺序`
 - 1.看是不是私有变量（形参和私有作用域里声明的）是的话就是它
 -2.若不是，则往上级作用域查找,查找过程叫做作用域链

 `什么是上级作用域？`
 >函数在哪里定义，则上级作用域就是谁
 `上级作用域只跟函数在哪定义有关，跟函数在哪里执行没有关系。`
##### 只对等号左边的进行赋值
>=:赋值，左边是变量，右边都应该是值。（如果是个函数表达式，把函数变成一个值（空间地址）赋值给变量）
```
console.log(fn);//undefined
var fn=function(){}
console.log(fn);//函数本身
```
```
//=>全局变量提升：var x; var y; var z; fn=AAAFFF000;
var x = 10,
    y = 20,
    z = 30;
function fn(x, y) {
    //=>[私有作用域]
    //=>形参赋值：x=10 y=20 (x/y都是私有变量)
    //=>变量提升：var x(忽略的,已经存在x这个名字了)
    console.log(x, y, z);//=>z不是私有变量是全局变量 10 20 30
    var x = 100;//=>私有的x=100
    y = 200;//=>私有的y=200
    z = 300;//=>全局的z=300
    console.log(x, y, z);//=>100 200 300
}
fn(x, y, z);//=>FN执行传递的是实参(实参都是值) fn(10,20,30)
console.log(x, y, z);//=>10 20 300

```

>真实项目中创建函数一般都用函数表达式
>1.因为只能对等号左边进行变量提升，所以变量提升完成后，当前函数只是声明了，没有定义，想要执行函数，只能放在赋值的代码之后执行，放在代码前会报错
>2.这种方法代码逻辑更加严谨，以后想要知道一个执行的函数做了什么功能，只需要向上查找定义的部分即可（不会存在定义的代码在执行下面的情况）
var fn = function sum(){
console.log(sum);//函数本身
console.log(1);
};
sum();//uncaught referenceerror:sum is not defined.sum在函数外面不能用在里面可以用
fn();

#####  不管条件是否成立都要进行变量提升
```
console.log(num);//undefined
console.log(fn);//undefined
if(1===1){
console.log(num);//undefined
console.log(fn);//函数体本身
var num =12;
function fn (){}
console.log(num);//12
console.log(fn);//函数体本身
}
```
> 老版本浏览器不是这样处理的：不管条件是否成立，都要进行变量提升（和新版不一样的地方，新版本function只是声明，老版本function依然是声明+定义）
```javascript
//=>变量提升：没有
f = function () {return true;};
g = function () {return false;};
~function () {
    //=>[私有作用域]
    //变量提升：g=undefined (不管条件是否成立都要进行变量提升，但是新版本的浏览器只对函数进行声明)
    if (g() && [] == ![]) {//=>Uncaught TypeError: g is not a function
        f = function () {return false;};
        function g() {return true;}
    }
}();
console.log(f());
console.log(g());
```

> 不管条件是否成立，判断体当中出现的var和function都会进行变量提升，但是新版本浏览器当中，function声明的变量只能提前声明不能定义了（函数是在判断体当中）
代码执行到判断地方
1）条件不成立;进入不到判断体当中赋值的代码执行不了，此事之前声明的变量或者函数依然是undefined。
2）条件成立：进入条件判断体中的第一件事情不是代码执行，而是把之前变量提升没有定义的函数首先定义了（进入到判断体中函数就定义了：迎合ES6中的块级作用域）
老版本浏览器不是这样处理的：不管条件是否成立，都要进行变量提升（和新版不一样的地方，新版本function只是声明，老版本function依然是声明+定义）

#####  关于重名的处理
> 在变量提升阶段，如果名字重复了，不会重新的进行声明，但是会重新的进行定义（后面赋的值会把前面赋的值给替换掉）
```
function fn() {
    var i = 1;
    return function (n) {
        console.log(n + i++);
    }
}
var f = fn();
f(10);//->11
fn()(10);//->11
f(20);//->22
fn()(20);//->21

```